<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Reed-Solomon erasure coding based on Leopard-RS, featuring:"><title>reed_solomon_simd - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="reed_solomon_simd" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.1 (ed61e7d7e 2025-11-07)" data-channel="1.91.1" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate reed_solomon_simd</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../reed_solomon_simd/index.html">reed_<wbr>solomon_<wbr>simd</a><span class="version">3.1.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#benchmarks" title="Benchmarks">Benchmarks</a></li><li><a href="#simple-usage" title="Simple usage">Simple usage</a><ul><li><a href="#example" title="Example">Example</a></li></ul></li><li><a href="#basic-usage" title="Basic usage">Basic usage</a></li><li><a href="#advanced-usage" title="Advanced usage">Advanced usage</a></li><li><a href="#benchmarks-against-other-crates" title="Benchmarks against other crates">Benchmarks against other crates</a></li><li><a href="#running-tests" title="Running tests">Running tests</a></li><li><a href="#safety" title="Safety">Safety</a></li><li><a href="#compatibility" title="Compatibility">Compatibility</a></li><li><a href="#credits" title="Credits">Credits</a></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>reed_<wbr>solomon_<wbr>simd</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/reed_solomon_simd/lib.rs.html#1-619">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Reed-Solomon erasure coding based on <a href="https://github.com/catid/leopard">Leopard-RS</a>, featuring:</p>
<ul>
<li><code>O(n log n)</code> complexity.</li>
<li>Entirely written in Rust.</li>
<li>Runtime selection of best SIMD implementation on both AArch64 (Neon) and x86(-64) (SSSE3 and AVX2) with
fallback to plain Rust.</li>
<li>Any combination of 1 - 32768 original shards with 1 - 32768 recovery shards.</li>
<li>Up to 65535 original or recovery shards is also possible with following limitations:</li>
</ul>
<div><table><thead><tr><th><code>original_count</code></th><th><code>recovery_count</code></th></tr></thead><tbody>
<tr><td><code>&lt;= 2^16 - 2^n</code></td><td><code>&lt;= 2^n</code></td></tr>
<tr><td><code>&lt;= 61440</code></td><td><code>&lt;= 4096</code></td></tr>
<tr><td><code>&lt;= 57344</code></td><td><code>&lt;= 8192</code></td></tr>
<tr><td><code>&lt;= 49152</code></td><td><code>&lt;= 16384</code></td></tr>
<tr><td><strong><code>&lt;= 32768</code></strong></td><td><strong><code>&lt;= 32768</code></strong></td></tr>
<tr><td><code>&lt;= 16384</code></td><td><code>&lt;= 49152</code></td></tr>
<tr><td><code>&lt;= 8192</code></td><td><code>&lt;= 57344</code></td></tr>
<tr><td><code>&lt;= 4096</code></td><td><code>&lt;= 61440</code></td></tr>
<tr><td><code>&lt;= 2^n</code></td><td><code>&lt;= 2^16 - 2^n</code></td></tr>
</tbody></table>
</div><h2 id="benchmarks"><a class="doc-anchor" href="#benchmarks">§</a>Benchmarks</h2><div><table><thead><tr><th>Original : Recovery</th><th>Encode</th><th>Decode (1% loss; 100% loss)</th></tr></thead><tbody>
<tr><td>32: 32</td><td>10.237 GiB/s</td><td>254.24 MiB/s ; 253.60 MiB/s</td></tr>
<tr><td>64: 64</td><td>8.6758 GiB/s</td><td>459.18 MiB/s ; 456.83 MiB/s</td></tr>
<tr><td>128 : 128</td><td>7.3891 GiB/s</td><td>753.11 MiB/s ; 758.65 MiB/s</td></tr>
<tr><td>256 : 256</td><td>6.3753 GiB/s</td><td>1.0391 GiB/s ; 1.0323 GiB/s</td></tr>
<tr><td>512 : 512</td><td>5.5076 GiB/s</td><td>1.1862 GiB/s ; 1.2542 GiB/s</td></tr>
<tr><td>1024 : 1024</td><td>4.8495 GiB/s</td><td>1.3017 GiB/s ; 1.4178 GiB/s</td></tr>
<tr><td>2048 : 2048</td><td>4.3733 GiB/s</td><td>1.3341 GiB/s ; 1.4640 GiB/s</td></tr>
<tr><td>4096 : 4096</td><td>3.9926 GiB/s</td><td>1.2008 GiB/s ; 1.3585 GiB/s</td></tr>
<tr><td>8192 : 8192</td><td>3.1220 GiB/s</td><td>942.68 MiB/s ; 1012.5 MiB/s</td></tr>
<tr><td>16384 : 16384</td><td>2.2468 GiB/s</td><td>701.36 MiB/s ; 687.75 MiB/s</td></tr>
<tr><td>32 768 : 32 768</td><td>1.6049 GiB/s</td><td>681.39 MiB/s ; 667.93 MiB/s</td></tr>
<tr><td>128 : 1 024</td><td>6.4068 GiB/s</td><td>857.36 MiB/s ; 856.25 MiB/s</td></tr>
<tr><td>1 000 : 100</td><td>5.6079 GiB/s</td><td>1021.7 MiB/s ; 1022.0 MiB/s</td></tr>
<tr><td>1 000 : 10 000</td><td>4.0041 GiB/s</td><td>1012.7 MiB/s ; 1014.9 MiB/s</td></tr>
<tr><td>8 192 : 57 344</td><td>2.3174 GiB/s</td><td>706.97 MiB/s ; 704.85 MiB/s</td></tr>
<tr><td>10 000 : 1 000</td><td>2.9598 GiB/s</td><td>924.42 MiB/s ; 942.26 MiB/s</td></tr>
<tr><td>57 344 : 8 192</td><td>1.8894 GiB/s</td><td>657.89 MiB/s ; 664.97 MiB/s</td></tr>
</tbody></table>
</div>
<ul>
<li>Single core AVX2 on an AMD Ryzen 5 3600 (Zen 2, 2019).</li>
<li>On an Apple Silicon M1 CPU throughput is about the same (+-10%).</li>
<li>MiB/s and GiB/s are w.r.t the total amount of data,
i.e. original shards + recovery shards.
<ul>
<li>For decoder this includes missing shards.</li>
</ul>
</li>
<li>Shards are 1024 bytes.</li>
<li>Encode benchmark
<ul>
<li>Includes <a href="struct.ReedSolomonEncoder.html#method.add_original_shard" title="method reed_solomon_simd::ReedSolomonEncoder::add_original_shard"><code>add_original_shard</code></a> and
<a href="struct.ReedSolomonEncoder.html#method.encode" title="method reed_solomon_simd::ReedSolomonEncoder::encode"><code>encode</code></a> of <a href="struct.ReedSolomonEncoder.html" title="struct reed_solomon_simd::ReedSolomonEncoder"><code>ReedSolomonEncoder</code></a>.</li>
</ul>
</li>
<li>Decode benchmark
<ul>
<li>Has two MiB/s values for 1% and 100% original shard loss, of maximum possible.</li>
<li>Provides minimum required amount of shards to decoder.</li>
<li>Includes <a href="struct.ReedSolomonDecoder.html#method.add_original_shard" title="method reed_solomon_simd::ReedSolomonDecoder::add_original_shard"><code>add_original_shard</code></a>,
<a href="struct.ReedSolomonDecoder.html#method.add_recovery_shard" title="method reed_solomon_simd::ReedSolomonDecoder::add_recovery_shard"><code>add_recovery_shard</code></a> and
<a href="struct.ReedSolomonDecoder.html#method.decode" title="method reed_solomon_simd::ReedSolomonDecoder::decode"><code>decode</code></a> of <a href="struct.ReedSolomonDecoder.html" title="struct reed_solomon_simd::ReedSolomonDecoder"><code>ReedSolomonDecoder</code></a>.</li>
</ul>
</li>
</ul>
<p>I invite you to clone <a href="https://github.com/AndersTrier/reed-solomon-simd">reed-solomon-simd</a> and run your own benchmark:</p>
<div class="example-wrap"><pre class="language-sh"><code>$ cargo bench main</code></pre></div><h2 id="simple-usage"><a class="doc-anchor" href="#simple-usage">§</a>Simple usage</h2>
<ol>
<li>Divide data into equal-sized original shards.
Shard size must be even (<code>shard.len() % 2 == 0</code>).</li>
<li>Decide how many recovery shards you want.</li>
<li>Generate recovery shards with <a href="fn.encode.html" title="fn reed_solomon_simd::encode"><code>reed_solomon_simd::encode</code></a>.</li>
<li>When some original shards get lost, restore them with <a href="fn.decode.html" title="fn reed_solomon_simd::decode"><code>reed_solomon_simd::decode</code></a>.
<ul>
<li>You must provide at least as many shards as there were original shards in total,
in any combination of original shards and recovery shards.</li>
</ul>
</li>
</ol>
<p>Note: This crate does not detect or correct errors within a shard. So if data corruption is a likely scenario, you should include an error detection hash with each shard, and skip feeding the corrupted shards to the decoder. Here are a few suggestions for very fast error detection hashes: CRC32c (4 bytes), HighwayHash (8, 16 or 32 bytes) or xxHash (4, 8 or 16 bytes).</p>
<h3 id="example"><a class="doc-anchor" href="#example">§</a>Example</h3>
<p>Divide data into 3 original shards of 64 bytes each and generate 5 recovery shards.
Assume then that original shards #0 and #2 are lost
and restore them by providing 1 original shard and 2 recovery shards.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>original = [
    <span class="string">b"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do "</span>,
    <span class="string">b"eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut e"</span>,
    <span class="string">b"nim ad minim veniam, quis nostrud exercitation ullamco laboris n"</span>,
];

<span class="kw">let </span>recovery = reed_solomon_simd::encode(
    <span class="number">3</span>, <span class="comment">// total number of original shards
    </span><span class="number">5</span>, <span class="comment">// total number of recovery shards
    </span>original, <span class="comment">// all original shards
</span>)<span class="question-mark">?</span>;

<span class="kw">let </span>restored = reed_solomon_simd::decode(
    <span class="number">3</span>, <span class="comment">// total number of original shards
    </span><span class="number">5</span>, <span class="comment">// total number of recovery shards
    </span>[  <span class="comment">// provided original shards with indexes
        </span>(<span class="number">1</span>, <span class="kw-2">&amp;</span>original[<span class="number">1</span>]),
    ],
    [  <span class="comment">// provided recovery shards with indexes
        </span>(<span class="number">1</span>, <span class="kw-2">&amp;</span>recovery[<span class="number">1</span>]),
        (<span class="number">4</span>, <span class="kw-2">&amp;</span>recovery[<span class="number">4</span>]),
    ],
)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(restored[<span class="kw-2">&amp;</span><span class="number">0</span>], original[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(restored[<span class="kw-2">&amp;</span><span class="number">2</span>], original[<span class="number">2</span>]);</code></pre></div><h2 id="basic-usage"><a class="doc-anchor" href="#basic-usage">§</a>Basic usage</h2>
<p><a href="struct.ReedSolomonEncoder.html" title="struct reed_solomon_simd::ReedSolomonEncoder"><code>ReedSolomonEncoder</code></a> and <a href="struct.ReedSolomonDecoder.html" title="struct reed_solomon_simd::ReedSolomonDecoder"><code>ReedSolomonDecoder</code></a> give more control
of the encoding/decoding process.</p>
<p>Here’s the above example using these instead:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>reed_solomon_simd::{ReedSolomonDecoder, ReedSolomonEncoder};
<span class="kw">use </span>std::collections::HashMap;

<span class="kw">let </span>original = [
    <span class="string">b"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do "</span>,
    <span class="string">b"eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut e"</span>,
    <span class="string">b"nim ad minim veniam, quis nostrud exercitation ullamco laboris n"</span>,
];

<span class="kw">let </span><span class="kw-2">mut </span>encoder = ReedSolomonEncoder::new(
    <span class="number">3</span>, <span class="comment">// total number of original shards
    </span><span class="number">5</span>, <span class="comment">// total number of recovery shards
    </span><span class="number">64</span>, <span class="comment">// shard size in bytes
</span>)<span class="question-mark">?</span>;

<span class="kw">for </span>shard <span class="kw">in </span>original {
    encoder.add_original_shard(shard)<span class="question-mark">?</span>;
}

<span class="kw">let </span>result = encoder.encode()<span class="question-mark">?</span>;
<span class="kw">let </span>recovery: Vec&lt;<span class="kw">_</span>&gt; = result.recovery_iter().collect();

<span class="kw">let </span><span class="kw-2">mut </span>decoder = ReedSolomonDecoder::new(
    <span class="number">3</span>, <span class="comment">// total number of original shards
    </span><span class="number">5</span>, <span class="comment">// total number of recovery shards
    </span><span class="number">64</span>, <span class="comment">// shard size in bytes
</span>)<span class="question-mark">?</span>;

decoder.add_original_shard(<span class="number">1</span>, original[<span class="number">1</span>])<span class="question-mark">?</span>;
decoder.add_recovery_shard(<span class="number">1</span>, recovery[<span class="number">1</span>])<span class="question-mark">?</span>;
decoder.add_recovery_shard(<span class="number">4</span>, recovery[<span class="number">4</span>])<span class="question-mark">?</span>;

<span class="kw">let </span>result = decoder.decode()<span class="question-mark">?</span>;
<span class="kw">let </span>restored: HashMap&lt;<span class="kw">_</span>, <span class="kw">_</span>&gt; = result.restored_original_iter().collect();

<span class="macro">assert_eq!</span>(restored[<span class="kw-2">&amp;</span><span class="number">0</span>], original[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(restored[<span class="kw-2">&amp;</span><span class="number">2</span>], original[<span class="number">2</span>]);</code></pre></div><h2 id="advanced-usage"><a class="doc-anchor" href="#advanced-usage">§</a>Advanced usage</h2>
<p>See <a href="rate/index.html" title="mod reed_solomon_simd::rate"><code>rate</code></a> module for advanced encoding/decoding
using chosen <a href="engine/trait.Engine.html" title="trait reed_solomon_simd::engine::Engine"><code>Engine</code></a> and <a href="rate/trait.Rate.html" title="trait reed_solomon_simd::rate::Rate"><code>Rate</code></a>.</p>
<h2 id="benchmarks-against-other-crates"><a class="doc-anchor" href="#benchmarks-against-other-crates">§</a>Benchmarks against other crates</h2>
<p>Use <code>cargo run --release --example quick-comparison</code>
to run few simple benchmarks against <a href="https://crates.io/crates/reed-solomon-16"><code>reed-solomon-16</code></a>, <a href="https://crates.io/crates/reed-solomon-erasure"><code>reed-solomon-erasure</code></a>, <a href="https://crates.io/crates/reed-solomon-novelpoly"><code>reed-solomon-novelpoly</code></a> and <a href="https://crates.io/crates/leopard-codec"><code>leopard-codec</code></a> crates.</p>
<p>This crate is the fastest in all cases on my AMD Ryzen 5 3600, except in the
case of decoding with about 42 or fewer recovery shards.
There’s also a one-time initialization (&lt; 10 ms) for computing tables
which can dominate at really small data amounts.</p>
<h2 id="running-tests"><a class="doc-anchor" href="#running-tests">§</a>Running tests</h2>
<p>Some larger tests are marked <code>#[ignore]</code> and are not run with <code>cargo test</code>.
Use <code>cargo test -- --ignored</code> to run those.</p>
<h2 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h2>
<p>The only use of <code>unsafe</code> in this crate is to allow for target specific optimizations in <a href="engine/struct.Ssse3.html" title="struct reed_solomon_simd::engine::Ssse3"><code>Ssse3</code></a>, <a href="engine/struct.Avx2.html" title="struct reed_solomon_simd::engine::Avx2"><code>Avx2</code></a> and <a href="crate::engine::Neon"><code>Neon</code></a>.</p>
<h2 id="compatibility"><a class="doc-anchor" href="#compatibility">§</a>Compatibility</h2>
<p>Starting from version 3.0.0, shard sizes that are not multiples of 64 are supported. However, if your shard size is a multiple of 64, it remains compatible across all versions.</p>
<h2 id="credits"><a class="doc-anchor" href="#credits">§</a>Credits</h2>
<p>This crate is a fork Markus Laire’s <a href="https://crates.io/crates/reed-solomon-16"><code>reed-solomon-16</code></a> crate, which in turn
is based on <a href="https://github.com/catid/leopard">Leopard-RS</a> by Christopher A. Taylor.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="algorithm/index.html" title="mod reed_solomon_simd::algorithm">algorithm</a></dt><dd>Algorithm documentation.</dd><dt><a class="mod" href="engine/index.html" title="mod reed_solomon_simd::engine">engine</a></dt><dd>Low-level building blocks for Reed-Solomon encoding/decoding.</dd><dt><a class="mod" href="rate/index.html" title="mod reed_solomon_simd::rate">rate</a></dt><dd>Advanced encoding/decoding using chosen <a href="engine/trait.Engine.html" title="trait reed_solomon_simd::engine::Engine"><code>Engine</code></a> and <a href="rate/trait.Rate.html" title="trait reed_solomon_simd::rate::Rate"><code>Rate</code></a>.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.DecoderResult.html" title="struct reed_solomon_simd::DecoderResult">Decoder<wbr>Result</a></dt><dd>Result of decoding. Contains the restored original shards.</dd><dt><a class="struct" href="struct.EncoderResult.html" title="struct reed_solomon_simd::EncoderResult">Encoder<wbr>Result</a></dt><dd>Result of encoding. Contains the generated recovery shards.</dd><dt><a class="struct" href="struct.Recovery.html" title="struct reed_solomon_simd::Recovery">Recovery</a></dt><dd>Iterator over generated recovery shards.</dd><dt><a class="struct" href="struct.ReedSolomonDecoder.html" title="struct reed_solomon_simd::ReedSolomonDecoder">Reed<wbr>Solomon<wbr>Decoder</a></dt><dd>Reed-Solomon decoder using <a href="engine/struct.DefaultEngine.html" title="struct reed_solomon_simd::engine::DefaultEngine"><code>DefaultEngine</code></a> and <a href="rate/struct.DefaultRate.html" title="struct reed_solomon_simd::rate::DefaultRate"><code>DefaultRate</code></a>.</dd><dt><a class="struct" href="struct.ReedSolomonEncoder.html" title="struct reed_solomon_simd::ReedSolomonEncoder">Reed<wbr>Solomon<wbr>Encoder</a></dt><dd>Reed-Solomon encoder using <a href="engine/struct.DefaultEngine.html" title="struct reed_solomon_simd::engine::DefaultEngine"><code>DefaultEngine</code></a> and <a href="rate/struct.DefaultRate.html" title="struct reed_solomon_simd::rate::DefaultRate"><code>DefaultRate</code></a>.</dd><dt><a class="struct" href="struct.RestoredOriginal.html" title="struct reed_solomon_simd::RestoredOriginal">Restored<wbr>Original</a></dt><dd>Iterator over restored original shards and their indexes.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Error.html" title="enum reed_solomon_simd::Error">Error</a></dt><dd>Represents all possible errors that can occur in this library.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.decode.html" title="fn reed_solomon_simd::decode">decode</a></dt><dd>Decodes in one go using <a href="struct.ReedSolomonDecoder.html" title="struct reed_solomon_simd::ReedSolomonDecoder"><code>ReedSolomonDecoder</code></a>,
returning restored original shards with their indexes.</dd><dt><a class="fn" href="fn.encode.html" title="fn reed_solomon_simd::encode">encode</a></dt><dd>Encodes in one go using <a href="struct.ReedSolomonEncoder.html" title="struct reed_solomon_simd::ReedSolomonEncoder"><code>ReedSolomonEncoder</code></a>,
returning generated recovery shards.</dd></dl></section></div></main></body></html>