<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Algorithm documentation."><title>reed_solomon_simd::algorithm - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="reed_solomon_simd" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.1 (ed61e7d7e 2025-11-07)" data-channel="1.91.1" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module algorithm</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../reed_solomon_simd/index.html">reed_<wbr>solomon_<wbr>simd</a><span class="version">3.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module algorithm</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#shard" title="Shard">Shard</a></li><li><a href="#rate" title="Rate">Rate</a><ul><li><a href="#benchmarks" title="Benchmarks">Benchmarks</a></li></ul></li><li><a href="#encoding" title="Encoding">Encoding</a><ul><li><a href="#high-rate-encoding" title="High rate encoding">High rate encoding</a></li><li><a href="#low-rate-encoding" title="Low rate encoding">Low rate encoding</a></li></ul></li><li><a href="#decoding" title="Decoding">Decoding</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate reed_<wbr>solomon_<wbr>simd</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">reed_solomon_simd</a></div><h1>Module <span>algorithm</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/reed_solomon_simd/lib.rs.html#37">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Algorithm documentation.</p>
<p>As I don’t understand algorithm fully myself,
I’ll just document some parts which I do understand.</p>
<h2 id="shard"><a class="doc-anchor" href="#shard">§</a>Shard</h2>
<ul>
<li>Reed-Solomon <code>GF(2^16)</code> erasure coding works on 16-bit elements (<a href="../engine/type.GfElement.html" title="type reed_solomon_simd::engine::GfElement"><code>GfElement</code></a>).</li>
<li>A <strong>shard</strong> is a byte-array which is interpreted as an array of <a href="../engine/type.GfElement.html" title="type reed_solomon_simd::engine::GfElement"><code>GfElement</code></a>:s.</li>
</ul>
<p>A naive implementation could e.g. require shards to be a multiple of <strong>2 bytes</strong>
and then interpret each byte-pair as low/high parts of a single <a href="../engine/type.GfElement.html" title="type reed_solomon_simd::engine::GfElement"><code>GfElement</code></a>:</p>
<div class="example-wrap"><pre class="language-text"><code>[ low_0, high_0, low_1, high_1, ...]</code></pre></div>
<p>However that approach isn’t good for SIMD optimizations.
Instead shards are required to be a multiple of <strong>64 bytes</strong>.
In each 64-byte block first 32 bytes are low parts of 32 <a href="../engine/type.GfElement.html" title="type reed_solomon_simd::engine::GfElement"><code>GfElement</code></a>:s
and last 32 bytes are high parts of those 32 <a href="../engine/type.GfElement.html" title="type reed_solomon_simd::engine::GfElement"><code>GfElement</code></a>:s.</p>
<div class="example-wrap"><pre class="language-text"><code>[ low_0, low_1, ..., low_31, high_0, high_1, ..., high_31 ]</code></pre></div>
<p>A shard then consists of one or more of these 64-byte blocks:</p>
<div class="example-wrap"><pre class="language-text"><code>// -------- first 64-byte block --------- | --------- second 64-byte block ---------- | ...
[ low_0, ..., low_31, high_0, ..., high_31, low_32, ..., low_63, high_32, ..., high_63, ... ]</code></pre></div><h2 id="rate"><a class="doc-anchor" href="#rate">§</a>Rate</h2>
<p>Encoding and decoding both have two variations:</p>
<ul>
<li><strong>High rate</strong> refers to having more original shards than recovery shards.
<ul>
<li>High rate must be used when there are over 32768 original shards.</li>
<li>High rate encoding uses <strong>chunks</strong> of <code>recovery_count.next_power_of_two()</code> shards.</li>
</ul>
</li>
<li><strong>Low rate</strong> refers to having more recovery shards than original shards.
<ul>
<li>Low rate must be used when there are over 32768 recovery shards.</li>
<li>Low rate encoding uses <strong>chunks</strong> of <code>original_count.next_power_of_two()</code> shards.</li>
</ul>
</li>
<li>Because of padding either rate can be used when there are
at most 32768 original shards and at most 32768 recovery shards.
<ul>
<li>High rate and low rate are not <sup id="fnref1"><a href="#fn1">1</a></sup> compatible with each other,
i.e. decoding must use same rate that encoding used.</li>
<li>With multiple chunks “correct” rate is generally faster in encoding
and not-slower in decoding.</li>
<li>With single chunk “wrong” rate is generally faster in decoding
if <code>original_count</code> and <code>recovery_count</code> differ a lot.</li>
</ul>
</li>
</ul>
<h3 id="benchmarks"><a class="doc-anchor" href="#benchmarks">§</a>Benchmarks</h3>
<ul>
<li>These benchmarks are from <code>cargo bench rate</code>
and use similar setup than <a href="../index.html#benchmarks" title="mod reed_solomon_simd">main benchmarks</a>,
except with maximum possible shard loss.</li>
</ul>
<div><table><thead><tr><th>original : recovery</th><th>Chunks</th><th><code>HighRateEncoder</code></th><th><code>LowRateEncoder</code></th><th><code>HighRateDecoder</code></th><th><code>LowRateDecoder</code></th></tr></thead><tbody>
<tr><td>1024 : 1024</td><td>1x 1024</td><td>175 MiB/s</td><td>176 MiB/s</td><td>76 MiB/s</td><td>75 MiB/s</td></tr>
<tr><td>1024 : 1025 (Low)</td><td>2x 1024</td><td>140</td><td><strong>153</strong></td><td>47</td><td><strong>59</strong></td></tr>
<tr><td>1025 : 1024 (High)</td><td>2x 1024</td><td><strong>152</strong></td><td>132</td><td><strong>60</strong></td><td>46</td></tr>
<tr><td>1024 : 2048 (Low)</td><td>2x 1024</td><td>157</td><td><strong>169</strong></td><td>70</td><td>70</td></tr>
<tr><td>2048 : 1024 (High)</td><td>2x 1024</td><td><strong>167</strong></td><td>151</td><td>69</td><td>68</td></tr>
<tr><td>1025 : 1025</td><td>1x 2048</td><td>125</td><td>126</td><td>44</td><td>43</td></tr>
<tr><td>1025 : 2048 (Low)</td><td>1x 2048</td><td>144</td><td>144</td><td><strong>65</strong> <strong>!!!</strong></td><td>53</td></tr>
<tr><td>2048 : 1025 (High)</td><td>1x 2048</td><td>144</td><td>145</td><td>53</td><td><strong>62</strong> <strong>!!!</strong></td></tr>
<tr><td>2048 : 2048</td><td>1x 2048</td><td>156</td><td>157</td><td>70</td><td>69</td></tr>
</tbody></table>
</div><h2 id="encoding"><a class="doc-anchor" href="#encoding">§</a>Encoding</h2>
<p>Encoding takes original shards as input and generates recovery shards.</p>
<h3 id="high-rate-encoding"><a class="doc-anchor" href="#high-rate-encoding">§</a>High rate encoding</h3>
<ul>
<li>Encoding is done in <strong>chunks</strong> of <code>recovery_count.next_power_of_two()</code> shards.</li>
<li>Original shards are split into chunks and last chunk
is padded with zero-filled shards if needed.
<ul>
<li>In theory original shards are padded to <a href="../engine/constant.GF_ORDER.html" title="constant reed_solomon_simd::engine::GF_ORDER"><code>GF_ORDER</code></a><code> - chunk_size</code> shards
but since <code>IFFT([0u8; x]) == [0u8; x]</code> and <code>xor</code> with <code>0</code> is no-op,
the chunks which contain only <code>0u8</code>:s can be ignored.</li>
</ul>
</li>
<li>Recovery shards fit into a single chunk
which is padded with unused shards if needed.</li>
<li>Recovery chunk is generated with following algorithm</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>recovery_chunk = FFT(
    IFFT(original_chunk_0, skew_0) xor
    IFFT(original_chunk_1, skew_1) xor
    ...
)</code></pre></div>
<p>This is implemented in <a href="../rate/struct.HighRateEncoder.html" title="struct reed_solomon_simd::rate::HighRateEncoder"><code>HighRateEncoder</code></a>.</p>
<h3 id="low-rate-encoding"><a class="doc-anchor" href="#low-rate-encoding">§</a>Low rate encoding</h3>
<ul>
<li>Encoding is done in <strong>chunks</strong> of <code>original_count.next_power_of_two()</code> shards.</li>
<li>Original shards fit into a single chunk
which is padded with zero-filled shards if needed.</li>
<li>Recovery shards are generated in chunks and last chunk
is padded with unused shards if needed.
<ul>
<li>In theory recovery shards are padded to <a href="../engine/constant.GF_ORDER.html" title="constant reed_solomon_simd::engine::GF_ORDER"><code>GF_ORDER</code></a><code> - chunk_size</code> shards
but chunks which contain only unused shards can be ignored.</li>
</ul>
</li>
<li>Recovery chunks are generated with following algorithm</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>recovery_chunk_0 = FFT( IFFT(original_chunk), skew_0 )
recovery_chunk_1 = FFT( IFFT(original_chunk), skew_1 )
...</code></pre></div>
<p>This is implemented in <a href="../rate/struct.LowRateEncoder.html" title="struct reed_solomon_simd::rate::LowRateEncoder"><code>LowRateEncoder</code></a>.</p>
<h2 id="decoding"><a class="doc-anchor" href="#decoding">§</a>Decoding</h2>
<p><strong>TODO</strong></p>
<div class="footnotes"><hr><ol><li id="fn1"><p>They seem to be compatible with single chunk. However I don’t quite
understand why and I don’t recommend relying on this.&nbsp;<a href="#fnref1">↩</a></p></li></ol></div></div></details></section></div></main></body></html>