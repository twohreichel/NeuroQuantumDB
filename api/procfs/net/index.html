<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Information about the networking layer."><title>procfs::net - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="procfs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.1 (ed61e7d7e 2025-11-07)" data-channel="1.91.1" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module net</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../procfs/index.html">procfs</a><span class="version">0.17.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module net</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#example" title="Example">Example</a></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate procfs</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">procfs</a></div><h1>Module <span>net</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/procfs/net.rs.html#3-254">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Information about the networking layer.</p>
<p>This module corresponds to the <code>/proc/net</code> directory and contains various information about the
networking layer.</p>
<h2 id="example"><a class="doc-anchor" href="#example">§</a>Example</h2>
<p>Here’s an example that will print out all of the open and listening TCP sockets, and their
corresponding processes, if know.  This mimics the “netstat” utility, but for TCP only.  You
can run this example yourself with:</p>
<blockquote>
<p>cargo run –example=netstat</p>
</blockquote>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>all_procs = procfs::process::all_processes().unwrap();

<span class="comment">// build up a map between socket inodes and process stat info:
</span><span class="kw">let </span><span class="kw-2">mut </span>map: HashMap&lt;u64, Stat&gt; = HashMap::new();
<span class="kw">for </span>p <span class="kw">in </span>all_procs {
    <span class="kw">let </span><span class="prelude-val">Ok</span>(process) = p <span class="kw">else </span>{
        <span class="comment">// process vanished
        </span><span class="kw">continue</span>;
    };
    <span class="kw">if let </span>(<span class="prelude-val">Ok</span>(stat), <span class="prelude-val">Ok</span>(fds)) = (process.stat(), process.fd()) {
        <span class="kw">for </span>fd <span class="kw">in </span>fds {
            <span class="kw">if let </span>FDTarget::Socket(inode) = fd.unwrap().target {
                map.insert(inode, stat.clone());
            }
        }
    }
}

<span class="comment">// get the tcp table
</span><span class="kw">let </span>tcp = procfs::net::tcp().unwrap();
<span class="kw">let </span>tcp6 = procfs::net::tcp6().unwrap();
<span class="macro">println!</span>(<span class="string">"{:&lt;26} {:&lt;26} {:&lt;15} {:&lt;8} {}"</span>, <span class="string">"Local address"</span>, <span class="string">"Remote address"</span>, <span class="string">"State"</span>, <span class="string">"Inode"</span>, <span class="string">"PID/Program name"</span>);
<span class="kw">for </span>entry <span class="kw">in </span>tcp.into_iter().chain(tcp6) {
    <span class="comment">// find the process (if any) that has an open FD to this entry's inode
    </span><span class="kw">let </span>local_address = <span class="macro">format!</span>(<span class="string">"{}"</span>, entry.local_address);
    <span class="kw">let </span>remote_addr = <span class="macro">format!</span>(<span class="string">"{}"</span>, entry.remote_address);
    <span class="kw">let </span>state = <span class="macro">format!</span>(<span class="string">"{:?}"</span>, entry.state);
    <span class="kw">if let </span><span class="prelude-val">Some</span>(stat) = map.get(<span class="kw-2">&amp;</span>entry.inode) {
        <span class="macro">println!</span>(<span class="string">"{:&lt;26} {:&lt;26} {:&lt;15} {:&lt;12} {}/{}"</span>, local_address, remote_addr, state, entry.inode, stat.pid, stat.comm);
    } <span class="kw">else </span>{
        <span class="comment">// We might not always be able to find the process associated with this socket
        </span><span class="macro">println!</span>(<span class="string">"{:&lt;26} {:&lt;26} {:&lt;15} {:&lt;12} -"</span>, local_address, remote_addr, state, entry.inode);
    }
}</code></pre></div></div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.ARPEntry.html" title="struct procfs::net::ARPEntry">ARPEntry</a></dt><dd>An entry in the ARP table</dd><dt><a class="struct" href="struct.ARPFlags.html" title="struct procfs::net::ARPFlags">ARPFlags</a></dt><dd>Flags for ARP entries</dd><dt><a class="struct" href="struct.ARPHardware.html" title="struct procfs::net::ARPHardware">ARPHardware</a></dt><dd>Hardware type for an ARP table entry.</dd><dt><a class="struct" href="struct.ArpEntries.html" title="struct procfs::net::ArpEntries">ArpEntries</a></dt><dd>ARP table entries.</dd><dt><a class="struct" href="struct.DeviceStatus.html" title="struct procfs::net::DeviceStatus">Device<wbr>Status</a></dt><dd>General statistics for a network interface/device</dd><dt><a class="struct" href="struct.InterfaceDeviceStatus.html" title="struct procfs::net::InterfaceDeviceStatus">Interface<wbr>Device<wbr>Status</a></dt><dd>Device status information for all network interfaces.</dd><dt><a class="struct" href="struct.RouteEntries.html" title="struct procfs::net::RouteEntries">Route<wbr>Entries</a></dt><dd>A set of ipv4 routes.</dd><dt><a class="struct" href="struct.RouteEntry.html" title="struct procfs::net::RouteEntry">Route<wbr>Entry</a></dt><dd>An entry in the ipv4 route table</dd><dt><a class="struct" href="struct.Snmp.html" title="struct procfs::net::Snmp">Snmp</a></dt><dd>This struct holds the data needed for the IP, ICMP, TCP, and UDP management
information bases for an SNMP agent.</dd><dt><a class="struct" href="struct.Snmp6.html" title="struct procfs::net::Snmp6">Snmp6</a></dt><dd>This struct holds the data needed for the IP, ICMP, TCP, and UDP management
information bases for an SNMP agent.</dd><dt><a class="struct" href="struct.TcpNetEntries.html" title="struct procfs::net::TcpNetEntries">TcpNet<wbr>Entries</a></dt><dd>TCP socket entries.</dd><dt><a class="struct" href="struct.TcpNetEntry.html" title="struct procfs::net::TcpNetEntry">TcpNet<wbr>Entry</a></dt><dd>An entry in the TCP socket table</dd><dt><a class="struct" href="struct.UdpNetEntries.html" title="struct procfs::net::UdpNetEntries">UdpNet<wbr>Entries</a></dt><dd>UDP socket entries.</dd><dt><a class="struct" href="struct.UdpNetEntry.html" title="struct procfs::net::UdpNetEntry">UdpNet<wbr>Entry</a></dt><dd>An entry in the UDP socket table</dd><dt><a class="struct" href="struct.UnixNetEntries.html" title="struct procfs::net::UnixNetEntries">Unix<wbr>NetEntries</a></dt><dd>Unix socket entries.</dd><dt><a class="struct" href="struct.UnixNetEntry.html" title="struct procfs::net::UnixNetEntry">Unix<wbr>NetEntry</a></dt><dd>An entry in the Unix socket table</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.IpForwarding.html" title="enum procfs::net::IpForwarding">IpForwarding</a></dt><dd>The indication of whether this entity is acting as an IP gateway in respect
to the forwarding of datagrams received by, but not addressed to, this
entity.  IP gateways forward datagrams.  IP hosts do not (except those
source-routed via the host).</dd><dt><a class="enum" href="enum.TcpRtoAlgorithm.html" title="enum procfs::net::TcpRtoAlgorithm">TcpRto<wbr>Algorithm</a></dt><dd>The algorithm used to determine the timeout value used for retransmitting
unacknowledged octets.</dd><dt><a class="enum" href="enum.TcpState.html" title="enum procfs::net::TcpState">TcpState</a></dt><dt><a class="enum" href="enum.UdpState.html" title="enum procfs::net::UdpState">UdpState</a></dt><dt><a class="enum" href="enum.UnixState.html" title="enum procfs::net::UnixState">Unix<wbr>State</a></dt></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.arp.html" title="fn procfs::net::arp">arp</a></dt><dd>Reads the ARP table</dd><dt><a class="fn" href="fn.dev_status.html" title="fn procfs::net::dev_status">dev_<wbr>status</a></dt><dd>Returns basic network device statistics for all interfaces</dd><dt><a class="fn" href="fn.route.html" title="fn procfs::net::route">route</a></dt><dd>Reads the ipv4 route table</dd><dt><a class="fn" href="fn.snmp.html" title="fn procfs::net::snmp">snmp</a></dt><dd>Reads the network management information by Simple Network Management Protocol</dd><dt><a class="fn" href="fn.snmp6.html" title="fn procfs::net::snmp6">snmp6</a></dt><dd>Reads the network management information of IPv6 by Simple Network Management Protocol</dd><dt><a class="fn" href="fn.tcp.html" title="fn procfs::net::tcp">tcp</a></dt><dd>Reads the tcp socket table</dd><dt><a class="fn" href="fn.tcp6.html" title="fn procfs::net::tcp6">tcp6</a></dt><dd>Reads the tcp6 socket table</dd><dt><a class="fn" href="fn.udp.html" title="fn procfs::net::udp">udp</a></dt><dd>Reads the udp socket table</dd><dt><a class="fn" href="fn.udp6.html" title="fn procfs::net::udp6">udp6</a></dt><dd>Reads the udp6 socket table</dd><dt><a class="fn" href="fn.unix.html" title="fn procfs::net::unix">unix</a></dt><dd>Reads the unix socket table</dd></dl></section></div></main></body></html>