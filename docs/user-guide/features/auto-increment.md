# Auto-Increment ID Generation

NeuroQuantumDB provides flexible automatic ID generation for database tables, eliminating the need to manually specify IDs when inserting records.

## Overview

When you define a table with an auto-increment column, NeuroQuantumDB automatically generates unique IDs for each inserted row. This simplifies application code and ensures data integrity.

## Quick Start

### Creating a Table with Auto-Increment

```sql
-- PostgreSQL-style (recommended)
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT NOT NULL
);

-- MySQL-style
CREATE TABLE products (
    id INTEGER AUTO_INCREMENT PRIMARY KEY,
    name TEXT NOT NULL,
    price FLOAT
);
```

### Inserting Records (ID is automatic!)

```sql
-- No need to specify the id column!
INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com');
INSERT INTO users (name, email) VALUES ('Bob', 'bob@example.com');
```

The database automatically assigns IDs 1, 2, 3, etc.

### Via REST API

```bash
# Create table with auto-increment
curl -X POST http://localhost:8080/api/v1/tables \
  -H "X-API-Key: your_key" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "users",
    "columns": [
      {"name": "id", "data_type": "BigSerial", "nullable": false, "auto_increment": true},
      {"name": "name", "data_type": "Text", "nullable": false},
      {"name": "email", "data_type": "Text", "nullable": false}
    ],
    "id_strategy": "AutoIncrement"
  }'

# Insert record WITHOUT specifying ID
curl -X POST http://localhost:8080/api/v1/records \
  -H "X-API-Key: your_key" \
  -H "Content-Type: application/json" \
  -d '{
    "table_name": "users",
    "record": {
      "name": "Alice",
      "email": "alice@example.com"
    }
  }'

# Response includes the generated ID:
# {"success": true, "data": {"inserted_id": 1}}
```

## Auto-Increment Data Types

### SERIAL Types (PostgreSQL-style)

| Type | Range | Storage | Use Case |
|------|-------|---------|----------|
| `SMALLSERIAL` | 1 to 32,767 | 2 bytes | Small lookup tables |
| `SERIAL` | 1 to 2,147,483,647 | 4 bytes | General purpose |
| `BIGSERIAL` | 1 to 9.2×10^18 | 8 bytes | Large tables (recommended) |

### AUTO_INCREMENT Constraint (MySQL-style)

```sql
CREATE TABLE products (
    id INTEGER AUTO_INCREMENT,
    name TEXT
);
```

### IDENTITY (SQL:2003 Standard)

```sql
-- Cannot override the ID
CREATE TABLE orders (
    id BIGINT GENERATED ALWAYS AS IDENTITY,
    total FLOAT
);

-- Can override with explicit value if needed
CREATE TABLE logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY,
    message TEXT
);
```

## ID Generation Strategies

NeuroQuantumDB supports three strategies for generating unique identifiers:

### 1. AutoIncrement (Default)

Sequential integer IDs starting from 1.

```json
{
  "id_strategy": "AutoIncrement"
}
```

**Best for:**
- Single-instance databases
- High-performance requirements
- Edge computing devices
- Neuromorphic computing (synaptic ID references)

**Performance characteristics:**
- B+Tree insert: O(1) amortized (sequential pages)
- Storage: 8 bytes per ID
- Throughput: 100k+ inserts/second

### 2. UUID

Random 128-bit universally unique identifiers.

```json
{
  "id_strategy": "Uuid"
}
```

**Best for:**
- Distributed systems
- Multi-node clusters
- When IDs should be unpredictable

**Performance characteristics:**
- B+Tree insert: Higher overhead (random page access)
- Storage: 16 bytes per ID (stored as TEXT)
- Throughput: ~50k inserts/second

### 3. Snowflake

Time-based 64-bit IDs with embedded machine identifier.

```json
{
  "id_strategy": {
    "Snowflake": {
      "machine_id": 1
    }
  }
}
```

**Best for:**
- Distributed systems requiring time-ordered IDs
- Log aggregation across multiple nodes
- Event sourcing architectures

**ID Structure:**
```
┌─────────────────────────────────────────────────────────────────┐
│ 41 bits: timestamp │ 10 bits: machine_id │ 12 bits: sequence   │
└─────────────────────────────────────────────────────────────────┘
```

## Strategy Comparison

| Feature | AutoIncrement | UUID | Snowflake |
|---------|:-------------:|:----:|:---------:|
| Storage size | 8 bytes | 16 bytes | 8 bytes |
| B+Tree performance | ★★★★★ | ★★☆☆☆ | ★★★★☆ |
| Distributed | ❌ | ✅ | ✅ |
| Time-sortable | ✅ | ❌ | ✅ |
| Human-readable | ✅ | ❌ | Partial |
| Predictable | Yes | No | Partial |

## Configuration Options

### Auto-Increment Configuration

```rust
// Rust API
AutoIncrementConfig {
    column_name: "id",
    next_value: 1,        // Starting value
    increment_by: 1,      // Step size
    min_value: 1,
    max_value: i64::MAX,
    cycle: false,         // Restart at min when max reached
}
```

### Custom Starting Value

```sql
-- Start IDs at 1000
CREATE TABLE users (
    id BIGINT GENERATED ALWAYS AS IDENTITY (START WITH 1000),
    name TEXT
);
```

### Custom Increment

```sql
-- Increment by 10 (useful for sharding)
CREATE TABLE events (
    id BIGINT GENERATED ALWAYS AS IDENTITY (INCREMENT BY 10),
    data TEXT
);
```

## Retrieving Generated IDs

### SQL

```sql
-- Use RETURNING clause
INSERT INTO users (name, email) 
VALUES ('Alice', 'alice@example.com')
RETURNING id;
```

### REST API Response

```json
{
  "success": true,
  "data": {
    "inserted_id": 42,
    "rows_affected": 1
  }
}
```

### Rust API

```rust
let row_id = storage.insert_row("users", row).await?;
println!("Inserted row with ID: {}", row_id);
```

## Best Practices

### 1. Use BIGSERIAL for New Tables

```sql
-- Recommended: Always use BIGSERIAL for primary keys
CREATE TABLE my_table (
    id BIGSERIAL PRIMARY KEY,
    ...
);
```

### 2. Never Manually Set Auto-Increment IDs

```sql
-- ❌ Don't do this
INSERT INTO users (id, name) VALUES (100, 'Alice');

-- ✅ Do this instead
INSERT INTO users (name) VALUES ('Alice');
```

### 3. Choose Strategy Based on Architecture

| Architecture | Recommended Strategy |
|--------------|---------------------|
| Single node | AutoIncrement |
| Multi-node cluster | UUID or Snowflake* |
| Event sourcing | Snowflake |
| Edge devices | AutoIncrement |
| Microservices | UUID |

\* **Note:** Multi-node cluster functionality is currently in Beta/Preview. For production use, single-node deployment with AutoIncrement is recommended. See [Cluster Mode documentation](../configuration.md#cluster-configuration-beta) for details.

### 4. Consider Neuromorphic Use Cases

For neuromorphic computing features (synaptic networks, Hebbian learning), use `AutoIncrement` because:
- Sequential IDs map efficiently to neural node indices
- Memory locality improves learning algorithm performance
- Smaller IDs reduce memory overhead in synaptic weight matrices

## Troubleshooting

### ID Sequence Gap

Gaps in IDs can occur after:
- Rolled back transactions
- Failed inserts
- Concurrent inserts

This is **normal behavior** and doesn't indicate data loss.

### Reaching Maximum ID

```rust
// Error when max is reached
CoreError::InvalidOperation {
    message: "Auto-increment column 'id' has reached maximum value"
}
```

**Solutions:**
1. Use `BIGSERIAL` (max: 9.2×10^18)
2. Enable `cycle: true` to restart at minimum
3. Archive old data and reset sequence

### Migrating Strategy

To change ID strategy on an existing table:
1. Create new table with desired strategy
2. Copy data (IDs will be regenerated)
3. Update foreign key references
4. Drop old table and rename new one

## See Also

- [QSQL Query Language](../qsql.md)
- [REST API Reference](../rest-api.md)
- [Storage Engine Architecture](../../developer-guide/architecture.md)
